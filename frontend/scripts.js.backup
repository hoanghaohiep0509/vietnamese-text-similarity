/**
 * Vietnamese Text Similarity Frontend
 * Main JavaScript file for handling UI interactions and API calls
 */

class TextSimilarityApp {
  constructor() {
    // C·∫≠p nh·∫≠t port API th√†nh 5001
    this.apiBaseUrls = [
      "http://127.0.0.1:5001/api",
      "http://localhost:5001/api",
      "http://0.0.0.0:5001/api",
    ];
    this.apiBaseUrl = this.apiBaseUrls[0];
    this.currentMode = "manual";
    this.datasets = [];
    this.comparisonChart = null;
    this.init();
  }

  async init() {
    console.log("üöÄ Initializing TextSimilarityApp...");

    // Setup UI first
    this.setupEventListeners();

    // Try to find working API URL
    await this.findWorkingApiUrl();

    // Check backend connection
    const backendHealthy = await this.checkBackendHealth();

    if (backendHealthy) {
      await this.loadDatasets();
      await this.updateTokenizerOptions();
      await this.loadMethodsInfo();
      await this.loadStatistics();
      console.log("‚úì Backend connection established");
    } else {
      console.warn("‚ö† Backend connection failed, using fallback data");
      this.datasets = this.getFallbackDatasets();
      this.populateDatasetSelect();
      this.setDefaultTokenizerOptions();
      this.populateMethodsWithDefaults();
      this.displayStatisticsError();
    }

    console.log("‚úì TextSimilarityApp initialized");
  }

  async findWorkingApiUrl() {
    for (const url of this.apiBaseUrls) {
      try {
        const response = await fetch(`${url}/health`, {
          method: "GET",
          headers: {
            Accept: "application/json",
          },
        });
        if (response.ok) {
          this.apiBaseUrl = url;
          console.log(`‚úì Found working API at: ${url}`);
          return;
        }
      } catch (error) {
        console.log(`‚úó Failed to connect to: ${url}`);
      }
    }
    console.warn("‚ö† No working API URL found, using default");
  }

  setupEventListeners() {
    // Input mode toggle
    const manualBtn = document.getElementById("manual-input-btn");
    const datasetBtn = document.getElementById("dataset-input-btn");

    if (manualBtn) {
      manualBtn.addEventListener("click", () => this.switchInputMode("manual"));
    }
    if (datasetBtn) {
      datasetBtn.addEventListener("click", () =>
        this.switchInputMode("dataset")
      );
    }

    // Text input character counting
    const text1 = document.getElementById("text1");
    const text2 = document.getElementById("text2");

    if (text1) {
      text1.addEventListener("input", (e) => {
        this.updateCharCount("char-count-1", e.target.value.length);
      });
    }
    if (text2) {
      text2.addEventListener("input", (e) => {
        this.updateCharCount("char-count-2", e.target.value.length);
      });
    }

    // Dataset selection
    const datasetSelect = document.getElementById("dataset-select");
    if (datasetSelect) {
      datasetSelect.addEventListener("change", (e) => {
        const index = e.target.value;
        if (index !== "" && this.datasets[index]) {
          const item = this.datasets[index];
          const preview1 = document.getElementById("preview-text1");
          const preview2 = document.getElementById("preview-text2");
          if (preview1) preview1.textContent = item.text1;
          if (preview2) preview2.textContent = item.text2;

          // Show preview section
          const previewSection = document.getElementById("dataset-preview");
          if (previewSection) previewSection.style.display = "block";
        }
      });
    }

    // Calculate button
    const calculateBtn = document.getElementById("calculate-btn");
    if (calculateBtn) {
      calculateBtn.addEventListener("click", () => this.calculateSimilarity());
    }

    // Compare all methods button
    const compareBtn = document.getElementById("compare-all-btn");
    if (compareBtn) {
      compareBtn.addEventListener("click", () => this.compareAllMethods());
    }

    // Export results button
    const exportBtn = document.getElementById("export-btn");
    if (exportBtn) {
      exportBtn.addEventListener("click", () => this.exportResults());
    }
  }

  switchInputMode(mode) {
    this.currentMode = mode;

    // Update button states
    document.querySelectorAll(".toggle-btn").forEach((btn) => {
      btn.classList.remove("active");
    });

    const activeBtn = document.getElementById(`${mode}-input-btn`);
    if (activeBtn) {
      activeBtn.classList.add("active");
    }

    // Show/hide input modes
    document.querySelectorAll(".input-mode").forEach((modeEl) => {
      modeEl.style.display = "none";
    });

    const activeMode = document.getElementById(`${mode}-input`);
    if (activeMode) {
      activeMode.style.display = "block";
    }
  }

  updateCharCount(elementId, count) {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = `${count} k√Ω t·ª±`;

      // Color coding for length
      if (count > 5000) {
        element.style.color = "#dc3545"; // Red for very long text
      } else if (count > 1000) {
        element.style.color = "#ffc107"; // Yellow for moderately long text
      } else {
        element.style.color = "#666"; // Default color
      }
    }
  }

  validateInputs(text1, text2) {
    if (!text1 || !text2) {
      this.showNotification("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß c·∫£ hai vƒÉn b·∫£n", "error");
      return false;
    }

    if (text1.length > 10000 || text2.length > 10000) {
      this.showNotification("VƒÉn b·∫£n qu√° d√†i (gi·ªõi h·∫°n 10000 k√Ω t·ª±)", "error");
      return false;
    }

    return true;
  }

  async calculateSimilarity() {
    try {
      this.showLoading(true, "ƒêang t√≠nh to√°n ƒë·ªô t∆∞∆°ng ƒë·ªìng...");

      const texts = this.getInputTexts();
      if (!texts || !this.validateInputs(texts.text1, texts.text2)) {
        return;
      }

      const tokenizer = document.getElementById("tokenizer").value;
      const method = document.getElementById("similarity-select").value;

      const response = await fetch(`${this.apiBaseUrl}/similarity`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          text1: texts.text1,
          text2: texts.text2,
          similarity_method: method, // S·ª≠a t·ª´ method th√†nh similarity_method
          tokenize_method: tokenizer, // S·ª≠a t·ª´ tokenizer th√†nh tokenize_method
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();

      
      this.displaySingleResult({
        similarity: result.similarity_score, 
        method: result.similarity_method,
        tokenizer: result.tokenize_method,
        execution_time: result.execution_time || 0,
        tokens_count_1: result.text1_length,
        tokens_count_2: result.text2_length,
      });
    } catch (error) {
      console.error("Error calculating similarity:", error);
      this.showNotification(
        "C√≥ l·ªói x·∫£y ra khi t√≠nh to√°n: " + error.message,
        "error"
      );
    } finally {
      this.showLoading(false);
    }
  }

  displaySingleResult(result) {
    // Show results section
    const resultsSection = document.getElementById("results-section");
    const singleResult = document.getElementById("single-result");
    const comparisonResult = document.getElementById("comparison-result");

    if (resultsSection) resultsSection.style.display = "block";
    if (singleResult) singleResult.style.display = "block";
    if (comparisonResult) comparisonResult.style.display = "none";

    // Update score
    const scoreElement = document.getElementById("similarity-score");
    if (scoreElement) {
      const score = (result.similarity * 100).toFixed(2);
      scoreElement.textContent = `${score}%`;
    }

    // Update details
    const methodElement = document.getElementById("method-used");
    if (methodElement) methodElement.textContent = result.method;

    const tokenizerElement = document.getElementById("tokenizer-used");
    if (tokenizerElement) tokenizerElement.textContent = result.tokenizer;

    const executionElement = document.getElementById("execution-time");
    if (executionElement)
      executionElement.textContent = `${result.execution_time.toFixed(3)}s`;

    const tokens1Element = document.getElementById("tokens-count-1");
    if (tokens1Element) tokens1Element.textContent = result.tokens_count_1;

    const tokens2Element = document.getElementById("tokens-count-2");
    if (tokens2Element) tokens2Element.textContent = result.tokens_count_2;

    // Scroll to results
    resultsSection.scrollIntoView({ behavior: "smooth" });
  }

  async compareAllMethods() {
    try {
      this.showLoading(true, "ƒêang so s√°nh c√°c ph∆∞∆°ng ph√°p...");

      const texts = this.getInputTexts();
      if (!texts || !this.validateInputs(texts.text1, texts.text2)) {
        return;
      }

      const response = await fetch(`${this.apiBaseUrl}/compare_methods`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          text1: texts.text1,
          text2: texts.text2,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const results = await response.json();
      this.displayComparisonResults(results);
    } catch (error) {
      console.error("Error comparing methods:", error);
      this.showNotification(
        "C√≥ l·ªói x·∫£y ra khi so s√°nh: " + error.message,
        "error"
      );
    } finally {
      this.showLoading(false);
    }
  }

  getInputTexts() {
    if (this.currentMode === "manual") {
      return {
        text1: document.getElementById("text1").value.trim(),
        text2: document.getElementById("text2").value.trim(),
      };
    } else {
      const datasetSelect = document.getElementById("dataset-select");
      const selectedIndex = datasetSelect.value;

      if (selectedIndex === "") {
        this.showNotification(
          "Vui l√≤ng ch·ªçn m·ªôt c·∫∑p vƒÉn b·∫£n t·ª´ dataset",
          "error"
        );
        return null;
      }

      const selectedData = this.datasets[selectedIndex];
      return {
        text1: selectedData.text1,
        text2: selectedData.text2,
      };
    }
  }

  displaySingleResult(result) {
    // Show results section
    const resultsSection = document.getElementById("results-section");
    const singleResult = document.getElementById("single-result");
    const comparisonResult = document.getElementById("comparison-result");

    if (resultsSection) resultsSection.style.display = "block";
    if (singleResult) singleResult.style.display = "block";
    if (comparisonResult) comparisonResult.style.display = "none";

    // Update score
    const scoreElement = document.getElementById("similarity-score");
    if (scoreElement) {
      const score = (result.similarity * 100).toFixed(2);
      scoreElement.textContent = `${score}%`;
    }

    // Update details
    document.getElementById("method-used").textContent = result.method;
    document.getElementById("tokenizer-used").textContent = result.tokenizer;
    document.getElementById(
      "execution-time"
    ).textContent = `${result.execution_time.toFixed(3)}s`;
    document.getElementById("tokens-count-1").textContent =
      result.tokens_count_1;
    document.getElementById("tokens-count-2").textContent =
      result.tokens_count_2;

    // Scroll to results
    resultsSection.scrollIntoView({ behavior: "smooth" });
  }

  displayComparisonResults(results) {
    // Show results section
    const resultsSection = document.getElementById("results-section");
    const singleResult = document.getElementById("single-result");
    const comparisonResult = document.getElementById("comparison-result");

    if (resultsSection) resultsSection.style.display = "block";
    if (singleResult) singleResult.style.display = "none";
    if (comparisonResult) comparisonResult.style.display = "block";

    // Create chart
    this.createComparisonChart(results);

    // Create table
    this.populateComparisonTable(results);

    // Scroll to results
    resultsSection.scrollIntoView({ behavior: "smooth" });
  }

  showLoading(show, message = "ƒêang x·ª≠ l√Ω...") {
    const loadingElement = document.getElementById("loading");
    const loadingMessage = document.getElementById("loading-message");

    if (loadingElement) {
      loadingElement.style.display = show ? "flex" : "none";
    }

    if (loadingMessage) {
      loadingMessage.textContent = message;
    }
  }

  showNotification(message, type = "info") {
    const notification = document.createElement("div");
    notification.className = `notification ${type}`;
    notification.innerHTML = `
            <div class="notification-icon">${this.getNotificationIcon(
              type
            )}</div>
            <div class="notification-message">${message}</div>
        `;

    document.body.appendChild(notification);

    // Auto remove after 5 seconds
    setTimeout(() => {
      notification.remove();
    }, 5000);
  }

  getNotificationIcon(type) {
    switch (type) {
      case "success":
        return "‚úì";
      case "error":
        return "‚úó";
      case "warning":
        return "‚ö†";
      default:
        return "‚Ñπ";
    }
  }

  async loadDatasets() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/dataset`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      this.datasets = await response.json();
      this.populateDatasetSelect();
    } catch (error) {
      console.error("Error loading datasets:", error);
      this.showNotification("Kh√¥ng th·ªÉ t·∫£i dataset", "error");
      this.datasets = this.getFallbackDatasets();
      this.populateDatasetSelect();
    }
  }

  getFallbackDatasets() {
    return [
      {
        text1: "H√† N·ªôi l√† th·ªß ƒë√¥ c·ªßa Vi·ªát Nam",
        text2: "Th·ªß ƒë√¥ c·ªßa Vi·ªát Nam l√† H√† N·ªôi",
      },
      {
        text1: "H·ªçc sinh ƒë·∫øn tr∆∞·ªùng",
        text2: "H·ªçc sinh t·ªõi tr∆∞·ªùng h·ªçc",
      },
    ];
  }
}

// Initialize the app when the page loads
document.addEventListener("DOMContentLoaded", () => {
  window.app = new TextSimilarityApp();
});